# .github/workflows/netflixwatcher.yml
# Strategy A with variable sleep and margin
# Run every 30 minutes using cron
# Do NOT use concurrency so overlapping runs are allowed
# Overlap is acceptable and helps avoid gaps
#
# Continuous coverage logic
# Cron interval is 30 minutes = 1800 seconds
# To keep a safety margin for runner startup, image build, and service boot,
# we enforce a minimum runtime of 35 minutes = 2100 seconds
# Sleep duration is randomized between 2100 and 3600 seconds (35 to 60 minutes)
#
# Repository constraint
# docker-compose.yml uses env_file: ./.env
# Docker Compose will fail if .env does not exist
# We generate .env at runtime from GitHub Secrets
#
# Environment mapping
# GitHub Secret EMAIL_PASS is mapped to EMAIL_PASSWORD
# because main.py reads EMAIL_PASSWORD from os.environ

name: NetflixWatcher

on:
  workflow_dispatch:
  schedule:
    # Run every 30 minutes
    - cron: "*/30 * * * *"

jobs:
  watcher:
    runs-on: ubuntu-latest

    # Worst case runtime
    # 3600 seconds sleep = 60 minutes
    # Plus build time, logs, cleanup
    timeout-minutes: 90

    steps:
      # Checkout repository source code
      - name: Checkout repository
        uses: actions/checkout@v4

      # Create .env required by docker-compose.yml env_file
      # Values are injected from GitHub Secrets
      - name: Create .env from GitHub Secrets
        shell: bash
        run: |
          set -euo pipefail

          # Validate required secrets exist
          for k in EMAIL_IMAP EMAIL_LOGIN EMAIL_PASS NETFLIX_EMAIL_SENDER; do
            if [ -z "${!k:-}" ]; then
              echo "Missing required secret/env: $k"
              exit 1
            fi
          done

          # Generate .env file for Docker Compose
          cat > .env <<EOF
          EMAIL_IMAP=${EMAIL_IMAP}
          EMAIL_LOGIN=${EMAIL_LOGIN}
          EMAIL_PASSWORD=${EMAIL_PASS}
          NETFLIX_EMAIL_SENDER=${NETFLIX_EMAIL_SENDER}
          EOF

          # Print only keys, never values
          echo "Environment variables loaded:"
          cut -d= -f1 .env | sed 's/^/- /'

        env:
          EMAIL_IMAP: ${{ secrets.EMAIL_IMAP }}
          EMAIL_LOGIN: ${{ secrets.EMAIL_LOGIN }}
          EMAIL_PASS: ${{ secrets.EMAIL_PASS }}
          NETFLIX_EMAIL_SENDER: ${{ secrets.NETFLIX_EMAIL_SENDER }}

      # Start Selenium + app containers
      # Detached mode is required so the job can proceed to the sleep stage
      - name: Start containers
        run: docker compose up -d --build

      # Generate a random sleep duration with a safety margin
      # Minimum is 2100 seconds (35 minutes)
      # Maximum is 3600 seconds (60 minutes)
      - name: Generate random sleep duration
        id: sleep_time
        shell: bash
        run: |
          set -euo pipefail

          MIN_SECONDS=2100
          MAX_SECONDS=3600

          SLEEP_SECONDS=$((RANDOM % (MAX_SECONDS - MIN_SECONDS + 1) + MIN_SECONDS))

          echo "sleep_seconds=$SLEEP_SECONDS" >> "$GITHUB_OUTPUT"
          echo "Selected sleep duration: $SLEEP_SECONDS seconds"

      # Keep containers alive for the randomly selected duration
      - name: Keep containers alive
        run: sleep ${{ steps.sleep_time.outputs.sleep_seconds }}

      # Always show container status and logs
      # Helps debug IMAP issues, Netflix sender mismatch, selenium issues, etc.
      - name: Show container logs
        if: always()
        run: |
          docker ps -a
          docker compose logs --no-color --tail=300

      # Always stop and clean up containers and volumes
      - name: Stop containers
        if: always()
        run: docker compose down -v
