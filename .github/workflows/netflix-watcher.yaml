# .github/workflows/netflixwatcher.yml
# This workflow runs the Netflix watcher as continuously as GitHub Actions allows.
# It uses a scheduled trigger and long-running jobs with controlled overlap.
# Overlap is intentional and helps avoid gaps when runners start slowly.

name: NetflixWatcher

on:
  workflow_dispatch:
  schedule:
    # Trigger the workflow every 6 hours
    # The job itself will usually run longer than this, creating overlap
    - cron: "0 */6 * * *"

jobs:
  watcher:
    runs-on: ubuntu-latest

    # The job may sleep up to 6h15m, so we give it a comfortable buffer
    # This stays under the practical GitHub Actions runtime limit
    timeout-minutes: 400

    steps:
      # Pull the repository so docker-compose.yml and the Dockerfile are available
      - name: Checkout repository
        uses: actions/checkout@v4

      # docker-compose.yml explicitly references ./.env via env_file
      # Because of that, we must generate a .env file here from GitHub Secrets
      - name: Create .env from secrets
        shell: bash
        run: |
          set -euo pipefail

          # Make sure all required secrets exist before continuing
          for k in EMAIL_IMAP EMAIL_LOGIN EMAIL_PASS NETFLIX_EMAIL_SENDER; do
            if [ -z "${!k:-}" ]; then
              echo "Missing required secret: $k"
              exit 1
            fi
          done

          # main.py expects EMAIL_PASSWORD, so we map EMAIL_PASS to that name
          cat > .env <<EOF
          EMAIL_IMAP=${EMAIL_IMAP}
          EMAIL_LOGIN=${EMAIL_LOGIN}
          EMAIL_PASSWORD=${EMAIL_PASS}
          NETFLIX_EMAIL_SENDER=${NETFLIX_EMAIL_SENDER}
          EOF
        env:
          EMAIL_IMAP: ${{ secrets.EMAIL_IMAP }}
          EMAIL_LOGIN: ${{ secrets.EMAIL_LOGIN }}
          EMAIL_PASS: ${{ secrets.EMAIL_PASS }}
          NETFLIX_EMAIL_SENDER: ${{ secrets.NETFLIX_EMAIL_SENDER }}

      # Start Selenium and the app in detached mode
      # Detached is required so the job can continue to the sleep step
      - name: Start containers
        run: docker compose up -d --build

      # Pick a random runtime so the job does not always stop at the same time
      # The minimum is 6 hours and the maximum is 6 hours and 15 minutes
      # This creates overlap with the next scheduled run and adds jitter
      - name: Generate sleep duration
        id: sleep_time
        shell: bash
        run: |
          MIN_SECONDS=21600
          MAX_SECONDS=22500
          SLEEP_SECONDS=$((RANDOM % (MAX_SECONDS - MIN_SECONDS + 1) + MIN_SECONDS))
          echo "sleep_seconds=$SLEEP_SECONDS" >> "$GITHUB_OUTPUT"
          echo "Selected sleep duration: $SLEEP_SECONDS seconds"

      # Keep the containers running for the selected amount of time
      - name: Keep containers alive
        run: sleep ${{ steps.sleep_time.outputs.sleep_seconds }}

      # Always print container status and recent logs for visibility
      - name: Show logs
        if: always()
        run: |
          docker ps -a
          docker compose logs --no-color --tail=300

      # Always clean up containers and volumes when the job ends
      # This avoids leaking resources on the GitHub runner
      - name: Stop containers
        if: always()
        run: docker compose down -v
