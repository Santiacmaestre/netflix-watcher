# .github/workflows/netflixwatcher.yml
# This workflow runs the Netflix watcher app on a schedule or manually.
# It pulls email-based location confirmation links from Netflix and confirms them via Selenium automation.

name: NetflixWatcher

on:
  # Allow manual trigger from the GitHub Actions UI
  workflow_dispatch:

  # Run automatically every 5 hours
  schedule:
    - cron: "0 */5 * * *" # At minute 0, every 5th hour (00:00, 05:00, 10:00, etc.)

jobs:
  watcher:
    runs-on: ubuntu-latest # Use the latest Ubuntu runner provided by GitHub

    # Give the job enough time to run (just under GitHubâ€™s 6-hour limit)
    timeout-minutes: 360 # 6 hours = 360 minutes (should be enough buffer for 5h runs)

    steps:
      # Step 1: Check out the repo so we can access the code and docker-compose files
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Create a .env file from GitHub Secrets
      # These secrets are required for connecting to the email inbox
      - name: Create .env from secrets
        shell: bash
        run: |
          # Stop immediately if anything fails or if any variable is missing
          set -euo pipefail

          # Check that all required secrets are available
          for k in EMAIL_IMAP EMAIL_LOGIN EMAIL_PASS NETFLIX_EMAIL_SENDER; do
            if [ -z "${!k:-}" ]; then
              echo "Missing required secret: $k"
              exit 1
            fi
          done

          # Write environment variables to a .env file for use by docker-compose
          # Note: the app expects EMAIL_PASSWORD, so we rename EMAIL_PASS
          cat > .env <<EOF
          EMAIL_IMAP=${EMAIL_IMAP}
          EMAIL_LOGIN=${EMAIL_LOGIN}
          EMAIL_PASSWORD=${EMAIL_PASS}
          NETFLIX_EMAIL_SENDER=${NETFLIX_EMAIL_SENDER}
          EOF
        env:
          EMAIL_IMAP: ${{ secrets.EMAIL_IMAP }}
          EMAIL_LOGIN: ${{ secrets.EMAIL_LOGIN }}
          EMAIL_PASS: ${{ secrets.EMAIL_PASS }}
          NETFLIX_EMAIL_SENDER: ${{ secrets.NETFLIX_EMAIL_SENDER }}

      # Step 3: Build and start the app and Selenium containers in the background
      - name: Start containers
        run: docker compose up -d --build

      # Step 4: Stream container logs in real-time
      # This keeps the workflow job alive as long as the app is running
      - name: Follow app logs
        run: docker compose logs -f

      # Step 5: Always print the status and recent logs when the job ends
      # This helps with debugging if the app exits unexpectedly
      - name: Show container status and recent logs
        if: always()
        run: |
          docker ps -a
          docker compose logs --no-color --tail=300

      # Step 6: Always shut down and clean up Docker resources when done
      # Prevents leftovers on the GitHub runner
      - name: Stop containers
        if: always()
        run: docker compose down -v
